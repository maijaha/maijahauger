<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Roboto+Condensed:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="project.css">
    <link href="index.html">
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/images/favicon.svg">
    <link rel="alternate icon" type="image/png" href="/images/favicon.png">
    <link rel="mask-icon" href="/images/favicon.svg" color="#000000">
</head>

<body>

    <div class="intro">
        <p>About</p>
      
        <div class="bread">
          <p>
            As a designer I try to be curious. <br><br>
            I enjoy working in collaborative settings, across disciplines. 
            I’m especially interested in public sector design, where I use visual design, facilitation, and method 
            development to create spaces for reflection, learning, and new perspectives. <br><br>
            Currently<br>Kartverket & Koalisjonen.<br>
            Freelance work on request.<br><br>
            Past (2022-25)<br>
            Designer, OsloMet. <br>
            Master thesis: Bending the Line. <br>
            Facilitated RSD13. <br>
            The Morning Studio, DAE, Netherlands.<br>
            Designer for Levende Gater, PBE, Oslo municipality. <br>
            Board member and Leader of student council, AHO, Oslo.  
          </p>
          <img src="images/makingpokemon.webp">
        </div>
      </div>
      

<div class="work"> 

    <div class="project bending">
        <p>Bending the Line</p><br><img src="images/bending.webp"></div> 
        <br>
        <div class="info bending">
    <p>Explored how Nav’s AI strategy could challenge linear organisational logics. By creating aesthetic disruptions and conversational tools,
         I helped surface tensions and open reflective dialogue. The outcome was a feedbackloop that allows situated learning through experimentation.
         My approach became a method book for an alternative way to deal with change.</p>
        <br> </div>
        <div class="facts bending">
        Master thesis, 2025. 
        <br>
        Collaborator: The Norwegian Labour and Welfare Administration (Nav).
        <br>
        Award: Complexity and Hollistic Approach, Halogen.
    </div>
    
     <div class="project coast">
    <p>Coast as a Host: Initiativsonen</p><br><img src="images/bugøynes.webp"></div>
        <br>
    <div class="info coast">
    <p>Proposed tools to strengthen belonging in Sør-Varanger by valuing contributions of all scales. These were framed as three steps: recruiting 
        initiators, cultivating initiative, and unlocking common spaces. Through scalable interventions and digital tools, the municipality can 
        better support both newcomers and locals, building long-term community resilience.</p>
        <br>    </div>
        <div class="facts coast">
        Digital Commons: Strategic Design for Society, 2024.
        <br>
        Collaborator: Kystutviklingssenteret / Sør-Varanger Utvikling.
        <br>
        With: Anna K. Halvorsen, Jenny Bjørgum, Per R. Christensen.
    </div>              

    <div class="project stretch">
    <p>The Stretch</p><br><img src="images/7.webp"> </div>
        <br>
    <div class="info stretch">
        <p>Co-designed with Bærum Child Welfare Services, this project developed a tool to explore tensions in employees core functions and values. By
             framing these “stretched” situations as opportunities for reflection, the tool created a basis for both local peer to peer support and 
             broader system-level conversations.</p>
        <br> </div>
        <div class="facts stretch">
        Service Design Futures, 2024.
        <br>
        Collaborator: The Child Welfare System, Bærum.
        <br>
        Nomination: Service Design Award.
    </div>

    <div class="project levende">
    <p>Levende Gater for Oslo PBE</p><br><img src="images/levende.webp"></div>
        <br>
    <div class="info levende">
        <p>A digital platform to connect Oslo neighbours by making local resources visible and encouraging sharing. Continued development
             with PBE and other student groups led to a consolidated contribution for PBE’s “Levende Gater”–report. The project showed how
              design can strengthen urban communities by surfacing hidden value in neighbourhoods.</p>
            <br> </div>
        <div class="facts levende">
            Service and Interaction Design Specialisation, 2023.
            <br>
            Collaborator: Oslo municipality, Agency for Planning and Building Services (PBE).
            <br>
            With: Ingvild Dekeyser.
        </div>

     <div class="project abstrakt">
    <p>Publication: abstrakt bok (book of abstracts)</p><br><img src="images/abstrakt.webp"></div>
        <br>
    <div class="info abstrakt">
        <p>Giving shape to design students academic work, otherwise easily forgotten and inaccessible to others.  I focused on the cover and graphic concept, and 
            learned how strong collaboration and clear role division can create beautiful things fast. I'm proud of this project because it was fun and full 
            of learning, as well as being my first paid design job.</p>
             <br> </div>
        <div class="facts abstrakt">
             Design Research, 2022.
             <br>
             For: Guttorm Ruud.
             <br>
             With: Jenny Bjørgum and Benjamin Romm.
    </div>

    <div class="project ease">
        <p>Space of Ease</p><br><img src="images/ease.webp"></div>
            <br>
        <div class="info ease">
            <p>Together with RICK and Dutch schools, we designed tools for students to shape “spaces of ease,” supporting psychological safety as a
                 prerequisite for creativity. The outcome was a set of adaptable methods that enabled youth to take ownership of their learning environments,
                  building both confidence and creative expression. </p>
                 <br>
                 </div>
        <div class="facts ease">
                 The Morning Studio, 2023.
                 <br>
                 For: RICK, Netherlands.
                 <br>
                 With: Zoé Monstrey and Finn Schumacher.
        </div>
        

        <div class="back" onclick="
            // Check if we're in an iframe (embedded in index.html)
            if (window.self !== window.top) {
                // Send message to parent window to show index content
                window.parent.postMessage('goHome', window.location.origin);
            } else {
                // Not in iframe, navigate normally
                document.body.style.transition = 'opacity 0.4s ease-in-out';
                document.body.style.opacity = '0';
                setTimeout(() => {
                    window.location.href='index.html';
                }, 400);
            }
        ">
            <p>Home</p>
        </div>

<script>
// Simple project cycling - show one project at a time
let currentIndex = 0;
const projects = ['bending', 'coast', 'stretch', 'levende', 'abstrakt', 'ease'];

// Images are now fixed at 400px height, so no height syncing needed
function syncImageHeight(sourceImage, targetImage) {
    // All images are now fixed at 400px height
    // This function is kept for compatibility but no longer needed
}


function showProject(index, animate = false, direction = 'forward') {
    // Get all project elements
    const allProjects = document.querySelectorAll('.project');
    const allInfos = document.querySelectorAll('.info');
    const allFacts = document.querySelectorAll('.facts');
    
    // Find current, previous, and next project elements
    const currentProject = projects[index];
    const prevIndex = (index - 1 + projects.length) % projects.length;
    const nextIndex = (index + 1) % projects.length;
    const prevProject = projects[prevIndex];
    const nextProject = projects[nextIndex];
    
    const currentProjectEl = document.querySelector('.project.' + currentProject);
    const prevProjectEl = document.querySelector('.project.' + prevProject);
    const nextProjectEl = document.querySelector('.project.' + nextProject);
    const oldVisibleEl = document.querySelector('.project.visible');
    const oldNextEl = document.querySelector('.project.next');
    const oldPrevEl = document.querySelector('.project.previous');
    
    if (animate && oldVisibleEl && oldVisibleEl !== currentProjectEl) {
        // Determine direction based on which side the new current is coming from
        const isBackward = direction === 'backward' || (oldPrevEl && oldPrevEl === currentProjectEl);
        
        if (isBackward) {
            // BACKWARD NAVIGATION: Center moves right, left moves to center, new image appears from left
            
            // Identify the NEW previous element (the one that will appear on the left after the animation)
            const newPrevElement = (prevProjectEl && prevProjectEl !== oldPrevEl && prevProjectEl !== currentProjectEl) ? prevProjectEl : null;
            
            // Ensure new previous element is completely hidden before animation starts
            if (newPrevElement) {
                newPrevElement.classList.remove('next', 'previous', 'visible');
                newPrevElement.classList.add('waiting-to-appear');
                newPrevElement.style.display = 'none';
            }
            
            // Phase 1: Center moves right AND left moves to center AT THE SAME TIME
            setTimeout(() => {
                // Old next moves out (disappears right)
                if (oldNextEl) {
                    oldNextEl.classList.add('moving-out');
                }
                
                // Left image (oldPrevEl) moves to center - SIMULTANEOUSLY with center moving right
                if (oldPrevEl) {
                    oldPrevEl.classList.add('moving-center');
                }
                
                // Center image (oldVisibleEl) moves to right position (becomes next) - SIMULTANEOUSLY
                if (oldVisibleEl) {
                    oldVisibleEl.classList.add('moving-to-next');
                }
            }, 10);
            
            // Update text when new picture arrives at center (after Phase 1 completes)
            setTimeout(() => {
                // Update info and facts for the new current project
                allInfos.forEach(el => {
                    el.classList.remove('visible');
                });
                allFacts.forEach(el => {
                    el.classList.remove('visible');
                });
                
                // Show info and facts for the new current project (which is now in center)
                document.querySelectorAll('.info.' + currentProject).forEach(el => el.classList.add('visible'));
                document.querySelectorAll('.facts.' + currentProject).forEach(el => el.classList.add('visible'));
            }, 510); // Right after Phase 1 completes (10ms start + 500ms duration)
            
            // Phase 2: ONLY AFTER Phase 1 FULLY completes, show NEW image on left
            setTimeout(() => {
                if (newPrevElement && newPrevElement !== currentProjectEl) {
                    // Step 1: Position it off-screen to the left (still hidden via display:none)
                    newPrevElement.classList.add('moving-in-from-left');
                    void newPrevElement.offsetHeight;
                    
                    // Step 2: Remove display:none but keep waiting-to-appear (still hidden)
                    newPrevElement.style.display = '';
                    void newPrevElement.offsetHeight;
                    
                    // Step 3: Remove waiting-to-appear and add previous class to make it visible
                    newPrevElement.classList.add('previous');
                    newPrevElement.classList.remove('waiting-to-appear');
                    void newPrevElement.offsetHeight;
                    
                    // Step 4: Start animation from left edge to final position
                    setTimeout(() => {
                        newPrevElement.classList.remove('moving-in-from-left');
                    }, 10);
                }
            }, 520); // Wait for Phase 1 to FULLY complete (10ms start + 500ms duration + 10ms buffer)
        } else {
            // FORWARD NAVIGATION: Center moves left, right moves to center, new image appears from right
            
            // Identify the NEW next element (the one that will appear on the right after the animation)
            const newNextElement = (nextProjectEl && nextProjectEl !== oldNextEl && nextProjectEl !== currentProjectEl) ? nextProjectEl : null;
            
            // Ensure new next element is completely hidden before animation starts
            if (newNextElement) {
                newNextElement.classList.remove('next', 'previous', 'visible');
                newNextElement.classList.add('waiting-to-appear');
                newNextElement.style.display = 'none';
            }
            
            // Phase 1: Center moves left AND right moves to center AT THE SAME TIME
            setTimeout(() => {
                // Old previous moves out (disappears left)
                if (oldPrevEl) {
                    oldPrevEl.classList.add('moving-out');
                }
                
                // Right image (oldNextEl) moves to center - SIMULTANEOUSLY with center moving left
                if (oldNextEl) {
                    oldNextEl.classList.add('moving-center');
                }
                
                // Center image (oldVisibleEl) moves to left position (becomes previous) - SIMULTANEOUSLY
                if (oldVisibleEl) {
                    oldVisibleEl.classList.add('moving-to-previous');
                }
            }, 10);
            
            // Update text when new picture arrives at center (after Phase 1 completes)
            setTimeout(() => {
                // Update info and facts for the new current project
                allInfos.forEach(el => {
                    el.classList.remove('visible');
                });
                allFacts.forEach(el => {
                    el.classList.remove('visible');
                });
                
                // Show info and facts for the new current project (which is now in center)
                document.querySelectorAll('.info.' + currentProject).forEach(el => el.classList.add('visible'));
                document.querySelectorAll('.facts.' + currentProject).forEach(el => el.classList.add('visible'));
            }, 510); // Right after Phase 1 completes (10ms start + 500ms duration)
            
            // Phase 2: ONLY AFTER Phase 1 FULLY completes, show NEW image on right and fade center image
            setTimeout(() => {
                if (newNextElement && newNextElement !== currentProjectEl) {
                    // Position it off-screen to the right (still hidden via display:none)
                    newNextElement.classList.add('moving-in-from-right');
                    void newNextElement.offsetHeight;
                    
                    // Remove display:none but keep waiting-to-appear (still hidden)
                    newNextElement.style.display = '';
                    void newNextElement.offsetHeight;
                    
                    // Make new image visible first
                    newNextElement.classList.add('next');
                    newNextElement.classList.remove('waiting-to-appear');
                    
                    // Prepare fade on center image moving left - add class BEFORE removing moving-in-from-right
                    if (oldVisibleEl && oldVisibleEl.classList.contains('moving-to-previous')) {
                        oldVisibleEl.classList.add('fade-opacity');
                    }
                    
                    // Start animation from right edge to final position - remove class to trigger transition
                    newNextElement.classList.remove('moving-in-from-right');
                    
                    // Force reflows on BOTH elements to ensure transitions start simultaneously
                    if (oldVisibleEl && oldVisibleEl.classList.contains('fade-opacity')) {
                        void oldVisibleEl.offsetHeight;
                    }
                    void newNextElement.offsetHeight;
                }
            }, 520); // Wait for Phase 1 to FULLY complete (10ms start + 500ms duration + 10ms buffer)
        }
        
        // After all animations complete, update classes
        setTimeout(() => {
            // Remove all classes
            allProjects.forEach(el => {
                el.classList.remove('visible', 'next', 'previous', 'moving-left', 'moving-center', 'moving-to-previous', 'moving-to-next', 'moving-out', 'moving-in-from-right', 'moving-in-from-left', 'waiting-to-appear', 'fade-opacity');
            });
            
            // Don't remove info/facts visibility - they're already showing the correct project from earlier
            // allInfos.forEach(el => {
            //     el.classList.remove('visible');
            // });
            // allFacts.forEach(el => {
            //     el.classList.remove('visible');
            // });
            
            // Set new state: previous, current, next
            if (prevProjectEl) {
                prevProjectEl.classList.add('previous');
                const mainImage = currentProjectEl.querySelector('img');
                const prevPreviewImage = prevProjectEl.querySelector('img');
                if (mainImage && prevPreviewImage) {
                    syncImageHeight(mainImage, prevPreviewImage);
                }
            }
            
            currentProjectEl.classList.add('visible');
            // Ensure info and facts are still visible for the current project
            document.querySelectorAll('.info.' + currentProject).forEach(el => el.classList.add('visible'));
            document.querySelectorAll('.facts.' + currentProject).forEach(el => el.classList.add('visible'));
            
            if (nextProjectEl) {
                nextProjectEl.classList.add('next');
                const mainImage = currentProjectEl.querySelector('img');
                const previewImage = nextProjectEl.querySelector('img');
                if (mainImage && previewImage) {
                    syncImageHeight(mainImage, previewImage);
                }
            }
            
        }, 1110); // Wait for all phases to complete (10ms + 500ms phase1 + 520ms phase2 delay + 20ms phase2 setup + 500ms phase2 animation + 60ms buffer)
    } else {
        // Immediate update (for initial load)
        allProjects.forEach(el => {
            el.classList.remove('visible', 'next', 'previous', 'moving-left', 'moving-center', 'moving-to-previous', 'moving-to-next', 'moving-out', 'moving-in-from-right', 'moving-in-from-left', 'waiting-to-appear', 'fade-opacity');
        });
        allInfos.forEach(el => {
            el.classList.remove('visible');
        });
        allFacts.forEach(el => {
            el.classList.remove('visible');
        });
        
        // Show previous, current, and next
        if (prevProjectEl) {
            prevProjectEl.classList.add('previous');
            const mainImage = currentProjectEl.querySelector('img');
            const prevPreviewImage = prevProjectEl.querySelector('img');
            if (mainImage && prevPreviewImage) {
                syncImageHeight(mainImage, prevPreviewImage);
            }
        }
        
        currentProjectEl.classList.add('visible');
        document.querySelectorAll('.info.' + currentProject).forEach(el => el.classList.add('visible'));
        document.querySelectorAll('.facts.' + currentProject).forEach(el => el.classList.add('visible'));
        
        if (nextProjectEl) {
            nextProjectEl.classList.add('next');
            const mainImage = currentProjectEl.querySelector('img');
            const previewImage = nextProjectEl.querySelector('img');
            if (mainImage && previewImage) {
                syncImageHeight(mainImage, previewImage);
            }
        }
        
    }
}

function nextProject() {
    currentIndex = (currentIndex + 1) % projects.length;
    showProject(currentIndex, true, 'forward'); // Enable animation
}

function previousProject() {
    currentIndex = (currentIndex - 1 + projects.length) % projects.length;
    showProject(currentIndex, true, 'backward'); // Enable animation
}

// Initialize as soon as DOM is ready (earlier than window.onload)
document.addEventListener('DOMContentLoaded', function() {
    // Fade in the page
    setTimeout(() => {
        document.body.classList.add('fade-in');
    }, 50);
    
    showProject(0, false);
    

    // Click on next/previous preview to navigate (carousel)
    document.addEventListener('click', function(e) {
        // Don't trigger on back button or intro area
        if (e.target.closest('.back') || e.target.closest('.intro')) {
            return;
        }
        
        // Check if clicking on next preview (image or container) - forward navigation
        const nextPreview = e.target.closest('.project.next');
        if (nextPreview) {
            nextProject();
            return;
        }
        
        // Check if clicking on previous preview (image or container) - backward navigation
        const prevPreview = e.target.closest('.project.previous');
        if (prevPreview) {
            previousProject();
            return;
        }
    });
});
</script>

</body>
</html>